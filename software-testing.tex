\chapter{Software Testing}

\section{Test-Prozess}

Innerhalb des Test-Prozess arbeiten mehrere Personen mit unterschiedliche Rollen:

\begin{description}
	\item[Testmanager (Führung)] Ansprechpartner für PL und Managemenet in kritischen Phasen. Plant Ressourcen, sucht verschiedene Lösungen und bewertet sie. Kann Leute führen. Entwickelt Teststrategien.
	\item[Testarchitekt, Testengineer (Ingenieur)] Plant und entwickelt die Testinfrastruktur. Entwickelt und verbessert Testmethoden und Testwerkzeuge. Entwickelt Teststrategien.
	\item[Testanalyst (Ingenieur)] Leitet aus Anforderungen Testszenarien ab. Entwickelt komplexe Testabläufe. Bestimmt Testdaten.
	\item[Testdatenverantwortlicher (Informatiker)] Pflegt, verwaltet, bewirtschaften und erweitert die Testdaten mittels Tools. Schnittstelle zwischen Testanalysten, Fach und IT. 
	\item[Tester (Fachperson)] Führt zuverlässig und exakt Tests aus. Dokumentiert präzis und wertfrei/neutral die Ergebnisse sowie die Abweichungen. Kann reproduzieren.
\end{description}

Wie die Abbildung \ref{fig:test-prozess} zeigt, ist der Test-Prozess (nach Noser) in vier Schritte eingeteilt.

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/test-prozess}
\caption{Test-Prozess}
\label{fig:test-prozess}
\end{figure}

\subsection{Schritt 1: Analysieren}

\begin{quote}
	Wie können die Entwickler entwickeln, wenn die Tester nicht wissen, was zu testen ist?
\end{quote}


\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/test-prozess-schritt-1}
\caption{Test-Prozess Schritt 1}
\label{fig:test-prozess-schritt-1}
\end{figure}

\textbf{Testen braucht eine Strategie}. Die Teststrategie bestimmt ob, was und wie tief getestet werden soll. Wo liegt der Fokus? Preis, Durchlaufzeit, Security, Usability, Performance, etc.? Vorgängig soll man sich darüber Gedanken machen und diese verbindlich festhalten. In der Teststrategie wird das Test-Vorgehen, verantwortliche Personen sowie den Prozess und die Hilfsmittel definiert. 

Warum ein Risiko basiertes Testen: Oft bleibt in kritischen Phasen nicht genug Zeit um \emph{alles} zu testen. Daher pro Iteration entscheiden, was in welchem Umgang getestet wird - kategorisieren und priorisieren. Nachfolgend werden drei Kritieren mit einem Wert von 1-3 bewertet. Das Produkt daraus gibt den Risiko Prioritäts Index (RPI):

\begin{itemize}
	\item Business Relevanz: Auswirkung bei Fehler, wie schlimm ist ein Fehler (3 = am schlimmsten)
	\item Auffindbarkeit: Wie schnell wird ein Fehler entdeckt? (1 = leicht erkennbar)
	\item Komplexität: Wie komplex ist die Anforderung und die Lösung dazu? (3 = sehr komplex)
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[width=0.8\linewidth]{fig/rpi-skala}
\caption{RPI-Skala}
\label{fig:rpi-skala}
\end{figure}

Der RPI definiert die Testtiefe, den Testumfang und die Anzahl der Wiederholungen. Somit ist der RPI das wichtigste Steuerungs- und Führungsinstrument.

Nebst dem Risiko basierten Testen gibt es noch andere Teststrategien:

\begin{itemize}
	\item ISO 29119: Was umfasst Qualität. Umfassende und ganzheitliche Betrachtung. Nach Vorlagen - Rad nicht neu erfinden.
	\item V-Modell: Tests auf jeder Stufe. Fehler so früh wie möglich entdecken.
	\item RPI: Risikiobasiertes Testen. So wenig wie möglich, aber das wo nötig.
	\item Kosten-Nutzen: Risikoabwägung. Welches Risiko wollen wir tragen, was darf es kosten?
\end{itemize}

Nebst dem Vorgehen spielen auch die \textbf{Tools} eine wichtige Rolle. Welche Tools werden für die Verwaltung von Anforderungen, Tests, Testabläufe und Testplanung verwendet. Mit was macht man Bug-Tracking, manuelles Testen, automatisiertes Testen, Lasttest, Datenmanipulation, Datengenerierung? Für alle Tools sollte man sicher immer Gedanken machen. Was ist das Ziel, wer kann das Tool bedienen, wie sieht die Lebensdauer aus, Kosten, wartbar, etc.

\subsection{Schritt 2: Vorbereiten}

\begin{quote}
	Tester und Q-Menschen sind nie bereit, sie können die Testvorbereitung sowie die Testinfrastruktur problemlos vergolden.
\end{quote}

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/test-prozess-schritt-2}
\caption{Test-Prozess Schritt 2}
\label{fig:test-prozess-schritt-2}
\end{figure}

Die Vorbereitungsphase legt die Basis für den Erfolg:

\begin{itemize}
	\item Test-Infrastruktur
	\item Test-Team (keine Diletanten!)
	\item Test-Daten
	\item Test-Automaten, Test-Automatisierung
	\item Eskalationswege
	\item NFA-Test
	\item Test-Stufen
	\item Test-Szenarien, Test Cases, Test-Fälle
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/testarten-zur-planung}
\caption{Testarten zur Planung}
\label{fig:testarten-zur-planung}
\end{figure}

Mittels Blackbox-Test wird das Ein- und Ausgabeverhalten überprüft. Dabei kann die Anzahl der Testfälle explodieren. Mittels Whitebox-Test werden die interne Logik des Systems oder Objekts angeschaut. 

Die Codeabdeckung ist eine Metrik, welche die die durch Tests erreichte Codeabdeckung beschreibt. Damit können die benötigten Testfälle ermittelt werden. Es gibt unterschiedliche Abdeckungen:
\begin{description}
	\item[Anweisungsüberdeckung] Jede Anweisung wird mind. 1 mal aufgerufen.
	\item[Zweig-, Entscheidungsabdeckung] Jeder Eintritt- und Austrittspunkt wird mind. einmal durchlaufen.
	\item[Pfadabeckung] Pfade im Code.
\end{description}

Wir können nicht alles testen, da es unzählige Pfade gibt. Wir brauchen eine Strategie, welche risikobasiert ist um die Frage zu beantworten, wie viel und wie tief getestet werden soll.

\subsection{Schritt 3: Durchführen}

\begin{quote}
	Die Praxis zeigt immer wieder, dass von Hand gepflegte Systeme in kritischen Momenten nicht mehr gepflegt werden, denn Testen geht immer vor. Doch genau dann sind die Kennzahlen als Entscheidungsbasis besonders wichtig.
\end{quote}

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/test-prozess-schritt-3}
\caption{Test-Prozess Schritt 3}
\label{fig:test-prozess-schritt-3}
\end{figure}

Auf Abbildung \ref{fig:wichtigkeit-des-testen} sieht man, dass sowohl der linke untere Quadrant und der rechte obere Quadrant dasselbe Ergebnis liefern. Das ist trügerisch!

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/wichtigkeit-des-testen}
\caption{Wichtigkeit des Testen}
\label{fig:wichtigkeit-des-testen}
\end{figure}

Agile Methoden setzen auf das Testen als Mittel zur Fortschrittsmessung. Schlussendlich wird das Testen innerhalb der Definition of Done formuliert. Ein erfolgreicher Test belegt faktenbasiert, dokumentiert, reproduzierbar und emotionslos, den tatsächlichen Stand/Fortschritt des Projekts. Wobei man im agilen Umfeld mit folgenden Problemen kämpft: Anforderungen nicht sauber definiert, nebst dem Schreiben des Codes geht das Test schreiben unter. Es fehlt die Rolle des Testmanager, kein Reporting. 

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/der-bug}
\caption{Der BUG (MEP!)}
\label{fig:der-bug}
\end{figure}

Ist jeder Fehler ein Fehler? Es macht Sinn die Fehler mit einer Severity (Schweregrad) kategorisieren:
\begin{itemize}
	\item 1 LOW: leichter Fehler, nur einzelne Testschritte betroffen.
	\item 2 MEDIUM: Betriebsstörender Fehler, Systemfunktion nicht beeinträchtig. Wesentlichtes funktioniert.
	\item 3 HIGH: Schwerer Fehler, Auswirkung auf Funktion.
	\item 4 URGENT: Fataler Fehler, Auswirkung auf ganzes System, Testabbruch.
\end{itemize}

Zudem stellt sich immer die Frage ob die Fehler reproduzierbar sind. Man spricht von \textbf{Beobachtungsgüte}:
\begin{itemize}
	\item A: Eindeutig festgestellter, belegbarer und reproduzierbarer Fehler.
	\item B: Nicht ohne weiteres reproduzierbar, aber wiederholt aufgetreten.
	\item C: Nicht reproduzierbar.	
\end{itemize}

\subsection{Schritt 4: }
tbd. in Testen 3 vorhanden...

\newpage
\section{Nichtfunktionale Anforderungen und der Testquadrant}

\subsection{Der Nutzen von Testen}

\begin{itemize}
	\item Das Testbudget kann eingeplant werden, Kosten für Nachbesserungen nicht.
	\item Fehler kosten Geld, Testen stellt sicher, dass Fehler früher systematisch erkennt werden.
	\item Ein konsequent gelebter Testprozess hat auch positiven Einfluss auf die Beschreibung der Anforderungen - es kann schlussendlich schneller entwickelt werden.
	\item Mittels eines Testprozess ist man gezwungen, dass Fehler, Änderungen und Neuanforderungen genau umschrieben werden.
	\item Testmanagement ist Führungsarbeit und gerade in agilen Prozessen dank nachweisbaren Fakten oft das einzig stete und somit verlässliche.
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/testen-nutzen-1}
\caption{Testen Nutzen 1}
\label{fig:testen-nutzen-1}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{fig/testen-nutzen-2}
	\caption{Testen Nutzen 2}
	\label{fig:testen-nutzen-2}
\end{figure}


\subsection{NFA}

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/nfa-testing}
\caption{NFA Testing}
\label{fig:nfa-testing}
\end{figure}

\subsection{Agile Testquadrant nach Brian Mark}

\begin{figure}[h!]
\centering
\includegraphics[width=0.5\linewidth]{fig/testquadrant}
\caption{Testquadrant}
\label{fig:testquadrant}
\end{figure}

\begin{description}
	\item[Quadrant 1 - unten links] Repräsentiert die Test getriebene Entwicklung - die Kernkomponente agiler Entwicklung. Die Unit- und Komponenten Tests in diesem Quadranten sind nicht unbedingt die ersten Tests die für eine bestimmte User Story geschrieben werden aber sie führen Design und Entwicklung an den richtigen Lösungsweg heran.
	
	\item[Quadrant 2 - oben links] Diese Tests unterstützt die Entwickler Teams auf einem höheren Niveau, denn sie sind am Geschäftsfall orientiert. Sie testen die extern wahrgenommene Qualität der vom Kunden definierten Features oder Anforderungen. Diese Tests treiben die Entwicklung auf einem höheren Level. Diese Tests werden von Business Experten leicht verstanden und aus diesem Grund in eine für sie lesbaren Sprache geschrieben. Hier auch - besser den Test vorher schreiben und erst danach implementieren. So kann der Entwickler es eigentlich gar nicht falsch implementieren. User Story sind oft zu unpräzise um den Need des Kunden genau zu spezifizieren. Daher eignet sich auch das Prototyping mit Hilfe diesen Tests.
	
	\item[Quadrant 3 - oben rechts] Das Reich der manuellen Tests! Es gibt exploratives, session-based, scenario sowie usability Testing. Darunter soll nicht nur die funktionalen Anforderungen getestet werden sondern auch die Nicht funktionalen Anforderungen. Beim explorativen Testen geht der Tester an die Software ran und schreibt quasi on the way die Testfälle und versucht "Fehler" zu finden. Diese haben sehr viel mit menschlicher Intelligenz sowie Intuition und Erfahrung zu tun. Daher sind diese schwer automatisierbar. Um hochwertige Software zu garantieren, reicht dieser Ansatz alleine nicht aus!
	
	\item[Quadrant 4 - unten rechts] Das Reich der NFA! In erster Linie werden hier nur NFA berücksichtigt. Dazu zählen wir Last-, Performance-, Security- und alle anderen ility-Tests. Obwohl sich diese Tests im letzten Quadranten befinden, sollen diese nicht erst am Schluss ausgeführt werden, sondern sobald wie möglich. Diese Tests können frühzeitig Schwachstellen der Architektur aufdecken. Probleme an dieser Stelle können zu grossen Umbauarbeiten führen. Die Erstellung dieser Tests ist mit grossem Aufwand verbunden. Für diese Tests sollten unbedingt entsprechende User Stories geschrieben werden - wobei Tool evaluiert werden und die Testumgebung definieren.
	
	\emph{Last- und Performance-Tests} erfordern oft erweitertes Fachwissen. Es braucht viel Vorlaufzeit und sind entsprechend aufwändig. Mittels Performance-Tests können Flaschenhälse im System ausgemacht werden. Load Tests stellen sicher, dass eine Applikation auch mit grosser Anzahl von gleichzeitigen Zugriffen fertig wird. Es gibt eine Reihe von Open Source Tools: JunitPerf, httperf, Apache JMeter, The Grinder, Pounder, ftptt, OpenWebLoad. Es gibt auch kommerzielle Tools. Die Evaluation und Einarbeitung in ein solches Tool braucht Zeit! Man sollte einmal eine Null-Linie definieren. Diese definiert den Ausgangspunkt von dem man sich verbessern möchte und kann so vergleichen - ob man wirklich Fortschritte erzielt. Es ist dabei wichtig, dass wir die Test reproduzierbar machen, in dem alle Faktoren dokumentiert werden (Hardware, System, Versionen usw.). Dabei sollte man sich auch immer um den Speicherverbrauch kümmern um allfälligen Memory-Leaks vorzubeugen - also messen! All diese Themen sollt ein Kapitel im Testplan gewidmet werden!
	
	Bei der \emph{Skalierbarkeit} geht es darum, dass auf einen Schlag mehr Benutzer die Applikation verwenden und das System diese doch verkraftet bzw. entsprechend skaliert werden kann.
	
	Für \emph{Security-Test} werden besser interne oder externe Spezialisten hinzugezogen. Sicherheitslöcher sind für eine Reputation einer Firma nicht gut und sollten dementsprechend prioritär behandelt weden.
	
	Die \emph{Wartbarkeit} kann nicht einfach so getestet werden. Sauber geschriebenen und kommentierten Code erhöhen die Wartbarkeit eines Systems. Es können Code-Guidlines definiert werden, allg. gültigste Standards und Konventionen sind einzuhalten, QS sollte auch Code- und Designreviews durchführen. Oder auch Pair-Programming oder die Clean-Code Bewegung sollten dazu führen.
	
	\emph{Kompatiblität und Interoperabilität} haben eine grosse Bedeutung wenn das System auf unterschiedlichen Systemen/Browser laufen muss. Das Testing kann schnell in ungeahnte Dimensionen steigen, wenn x-Geräte/Browser berücksichtigt werden müssen. Vielleicht sollte man auch auf Anbieter zurückgreifen, welche das für einen machen.
	
	\emph{Barrierefreiheit} - Kann die Applikation auch von sehbehinderten Menschen bedient werden? Warum grenzen wir diese aus?
	
	\emph{Zuverlässigkeit} beschäftigt sich mit der Frage, wie lange das System lauft bis es abstürzt oder einfriert. Kennzahlen sind hier MTF (mean time to failure) und MTBF (mean time between failures). Um das 1:1 testen zu können, braucht man oft einen langen Zeitraum um die Langzeitstabilität zu prüfen, was oft gar nicht möglich ist.
	
	Die \emph{Installierbarkeit} kann mit virtuellen Maschinen sehr gut und effizient verifiziert werden.
	 
\end{description}