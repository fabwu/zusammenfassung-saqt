\chapter{Applikations-Architektur}

\section{Software Architektur Grundbegriffe}

Nachfolgend die Definition von Software Architektur:

\begin{quote}
Die Architektur eines Softwaresystems besteht aus seinen Strukturen, der Zerlegung in Komponenten, deren Schnittstellen und Beziehungen untereinander.
\end{quote}

Die Definition baut wiederum auf dem Systembegriff auf, welcher eine Gesamtheit von Elementen mit klarer Abgrenzung zu seiner Umwelt ist. Daraus folgt, dass eine Architektur die Komponenten eines Systems definieren muss. Zudem sollten die Beziehungen zwischen diesen Komponenten charakterisiert und die wesentlichen Merkmale des Systems beschrieben werden. Dabei wird zwischen den statischen (Bauplan) und dynamischen Aspekten (Ablaufplan) unterschieden.

Es werden verschiedene Arten von Architekten unterschieden. Der Infrastructre Architect modelliert das \textit{Versorgungsnetz} des Systems. Der Enterprise Architect hat den Überblick über das grosse Ganze und entwirft sozusagen den \textit{Stadtplan}. In dieser Zusammenfassung konzentrieren wir uns aber auf den Application Architect (auch Solution Architect), der den \textit{Hausplan} entwirft.

Wie in der Bauarchitektur wird der Stil einer Softwarearchitektur von den Anforderung getrieben. Möchte man ein Gebäude zur Verteidigung erstellen, baut man keinen ästhetischen Glasturm, sondern ein solides Bollwerk aus Stein. Auch auf dem Bau existieren meist mehrere Lösungen für das ein und dasselbe Problem. Möchte man z.B. eine mobile Unterkunft kann man ein Zelt mitnehmen oder in einem Wohnwagen schlafen. Beides hat seine Vor- bzw. Nachteile. Es gibt aber auch Unterschiede zwischen Bau- und Softwarearchitektur. So lässt sich Software z.B. fast beliebig oft Umbauen ohne grösseren Schaden anzurichten. Das fördert eine iterative, inkrementelle Vorgehensweise. Das grosse Problem der Softwarearchitektur ist, dass man nicht einfach davor stehen kann um sie zu sehen wie bei der Gebäudearchitektur.

Das oberste Ziel einer guten Architektur ist eine Reduzierung der Komplexität. Diese Reduzierung kann z.B. durch Zerlegung in Komponenten, durch Abstraktion, Wiederverwendung oder einer guten Dokumentation erreicht werden. Die Bedeutung einer guten Architektur nimmt zu, weil heutige Systeme meist hochkomplex und integriert sind sowie sich laufend an neue Anforderungen anpassen müssen. Abbildung \ref{fig:begriffe} zeigt einen Überblick über die wichtigsten Begriffe für einen Architekten.

\begin{figure}
\centering
\includegraphics[width=0.6\linewidth]{fig/begriffe}
\caption{Grundlegende Begriffe}
\label{fig:begriffe}
\end{figure}

Bei einem Architekturentwurf werden Anforderungen, Qualitätsmerkmale und Rahmenbedingungen in den Prozess hineingegeben und heraus kommt eine Architektur welche durchführbar und entwicklungsfähig ist. Um so eine Architektur hinzukriegen, werden die Methoden in Abbildung \ref{fig:begriffe} angewendet. Abbildung \ref{fig:twin-peaks} zeigt das erweitere Twin Peaks Modell. Es soll aufzeigen dass die Architektur der \textbf{Vermittler} zwischen Anforderungen und Konstruktion ist. Zudem wird das ganze System in einem iterativen Prozess entworfen, was die Spirale darstellen soll.

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{fig/twin-peaks}
\caption{Erweitertes Twin Peaks Modell}
\label{fig:twin-peaks}
\end{figure}

Der iterative, inkrementelle Prozess des Architekturentwurfs läuft immer gleich ab:
\begin{enumerate}
	\item Analyse der Anforderungen und Auflösung von Konflikten
	\item Anwendung von Prinzipien, Taktiken \& Mustern
	\item Treffen von Entscheidungen \& Kompromissen
	\item Bewertung von Alternativen
	\item Bereitstellen von Sichten für Beteiligte
	\item Dokumentation und Bewertung von Entscheidungen
	\item Wenn Entwurf ok umsetzen sonst \verb|goto 1|
\end{enumerate}
Zum Schluss: Jedes System hat eine Architektur auch wenn keine Beschreibung ausserhalb des Codes existiert und sie in der Implementierung schwer zu erkennen ist.

Der Verfall von Software tritt ein, wenn das System zunehmend mit neuen Funktionen ausgestattet wird ohne sich dabei neue Gedanken über die Architektur zu machen. Das ist ein natürlicher Prozess, welche anschliessend ein Refactoring erfordert.

Der Unterschied zwischen Architektur und Design lässt sich gut an einem Beispiel ausmachen: Der Architekt definiert, dass die Komponente eine REST-Schnittstelle anbietet. Der Software-Entwickler setzt diese Schnittstelle konkret um - welche Ressourcen, welche Parameter usw.

\section{Requirement-Engineering}
Jedes Software-Projekt steht und fällt mit den Anforderungen. Karl Wiegers und Joy Beatty sagen, dass die Anforderungen nicht gleich ins kleinste Detail bekannt sein müssen, sondern nur immer soweit, dass das Entwicklungs-Team mit dem nächsten Schritt fortfahren kann. Zudem muss man sich immer bewusst sein, dass das was der Kunde sagt, oft nicht das ist was er meint.

In den letzten Jahren hat die Business-Analyse an Bedeutung gewonnen. Doch unterschätzt man allgemein immer noch die Wichtigkeit des Requirement-Engineering. Die Architektur sieht man als Brücke zwischen den Geschäftszielen und dem Software-System.

Inhärente (angeboren, innewohnend) Schwierigkeiten bei der Anforderungsanalyse:
\begin{itemize}
	\item Verständnis: Stakeholder können nicht wirklich wissen was sie wollen (im Sinne der IT Lösung).
	\item Kommunikation: Komplex, unklar, Business-IT Gap
	\item Kontrolle: Schwierig für den Software-Entwicklungsprozess
	\item Nichttrennbare Verantwortlichkeiten: Alles scheint von allem abzuhängen
\end{itemize}

Zufällige Schwierigkeiten bei der Anforderungsanalyse:
\begin{itemize}
	\item Anforderungen später schreiben: nicht hilfreich für die Entwicklung (aber: rapid prototyping)
	\item Widersprüchliche Interessen: Marketing (hype), allg. Dokumentation (unabh. von Anforderungen), Verträge. Das ist die Aufgabe des Architekten!
	\item Ungenügende Anstrengungen, weil ich vielleicht keinen Bock haben mit Person X zu reden.
	\item Unentdeckt: Schlichtweg vergessen oder unbekannt.
\end{itemize}

Anforderungen müssen SMART sein. SMART bedeutet:
\begin{description}
	\item[Specific:] Eindeutig und konsistent (Beschrieben mit angemessenem Detaillierungsgrad)
	\item[Measurable:] Messbar (Wie kann beurteilt werden, ob die Anforderung erreicht wurde?)
	\item[Attainable:] Erreichbar (Technisch machbar mit dem aktuellen Stand der Technik)
	\item[Realizable:] Umsetzbar (Unter den gegebenen Randbedingungen und verfügbare Ressourcen)
	\item[Traceable:] Nachverfolgbar (Konzeption - Spezifikation - Design - Implementation - Test)
\end{description}

\begin{figure}[h!]
\centering
\includegraphics[width=0.75\linewidth]{fig/requirements-gathering-and-analysis}
\caption{Requriements Gathering and Analysis}
\label{fig:requirements-gathering-and-analysis}
\end{figure}

\section{Funktionale Anforderungen: Use cases und User Stories}
\label{sec:funktionale-anforderungen}

Um funktionale Anforderungen aufzunehmen gibt es grundsätzlich zwei Mittel: User Story und Use Cases. Den Unterschied zwischen den beiden Arten beschreibe ich gerne wie folgt: Eine User Story ist ein leichtgewichtiges Planungsinstrument, welches den Dialog mit dem Kunden fördert. Ein Use Case ist ein schwergewichtiges Dokumentationsinstrument in welchem die Anforderung detailliert spezifiziert wird. Die User-Story sind mehr Business getrieben die Use Cases sind eher auf der technischen Seite anzusiedeln.

Falls eine User Story zu gross erscheint, kann diese als Epic angesehen werden. Wobei das Epic dann in mehrere User Storys unterteilt wird. Eine User Story hat das Muster \emph{“As a [role] I can [function] so that [rationale].”}. Gute User Stories sind INVEST (Independent, Negotiable, Valuable, Estimatable, Small, Testable). Zudem hat jeder User Story entsprechende Akzeptanzkriterien (Definition of Done).

Oft macht man folgende Fehler beim verfassen von User Stories: Too formal or too much detail, Technical tasks masquerading as stories, Skipping the conversation.

Nachfolgend ein Use-Case Template:

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/use-case-template}
\caption{Use Case Template}
\label{fig:use-case-template}
\end{figure}

\newpage
Alles was wir umsetzen basiert immer auf dem Bedürfnis von jemanden. Dahinter stecken Ziele die erreicht werden sollen. Ziele existieren auf unterschiedlichen Stufen - uns bekannt als Zielhierarchien. 

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\linewidth]{fig/zielhierarchien}
\caption{Zielhierarchien}
\label{fig:zielhierarchien}
\end{figure}

Diese Hiearchien können von Top-Down oder Bottom-Up notiert werden. Nachfolgend ein Beispiel: "I want this sales contract. To do that I have to take this manager out to lunch. To do that I have to get some cash. To do that I have to withdraw money from this ATM. To do that I have to get it to accept my identity. To do that I have to get it to read my ATM card. To do that I have to find the card slot."

Die verschiedenen Farben definieren die Flughöhe. Auf Stufe weiss ist es noch sehr abstrakt. Hier haben wir im generellen die Komponenten, wie Bestellungen oder Buchungen. Basierend auf denen können auf Stufe blau die eigentlichen Benutzer-Ziele definiert werden, wie Buchung stornieren, Bestellung ausliefern. Diese basieren auf irgendwelchen Funktionen, welche wir auf Stufe indigo ansiedeln. Die Stufe schwarz ist immer sehr technisch wie beispielsweise "2 Faktor Authentfizierung". Flache Listen von Use-Cases müssen gruppiert werden. Ein Beispiel wäre nach Mitarbeiter-Funktionen.

Folgendes gilt es zu beachten, wenn die Schritte innerhalb des Use-Cases als Text verfasst werden:
\begin{itemize}
	\item Einfach formulierte Sätze beschreiben aktive Handlungen (Subjekt - Verb - Objekt).
	\item Vogelperspektive und nicht Systemsicht verwenden.
	\item Ziele entsprechen Absichten.
	\item Zeige wie der Prozess im Hinblick auf das Ziel fortschreitet.
	\item Ziel von Überprüfungen klarmachen.
	\item Wiederholungen direkt schreiben (kein Pseudocode).
\end{itemize}

Ein Vision-Statement hat folgende Inhalte: For [customer] Who [needs... or has opportunity] The [product] Is [category] That [major capability, benefit, ...] Unlike [alternative, current system, current practice] Our Product [differentiation, advantages, ...].

\section{Nichtfunktionale Anforderungen: Szenarios}

Eine Software richtet sich nicht nur nach den Anforderungen des Kunden (funktionalen Anforderungen), sondern wird auch durch Qualitätsansprüche an die Architektur (nichtfunktionale Anforderungen) beeinflusst. Nichtfunktionale Anforderungen werden einerseits durch Randbedingungen (Constraints) vorgegeben. So muss z.B. eine bestehende Softwareplattform genutzt werden oder die Zeit und Ressourcen sind zu knapp um eine verteilte Anwendung zu bauen. Die Randbedingungen schränken den Architekten bei seinen Entscheidungen also ein. 
Es gibt aber auch nichtfunktionale Anforderungen die ein Architekt sehr wohl beeinflussen kann. Dazu gehören z.B. Benutzbarkeit, Erweiterbarkeit usw. Das sind die sogenannten Qualitätsattribute. Qualitätsattribute müssen immer messbar und testbar sein. Da ein Qualitätsattribut wie eine Anforderung ist, muss auch diese SMART (siehe Abschnitt \ref{sec:funktionale-anforderungen}) sein. Die Qualitätsattribute lassen sich durch bestimmte Strukturen und Verhaltensweisen erfüllen, die von der Architektur vorgegeben werden. Funktionale Anforderungen werden erfüllt, indem bestimmte Elemente der Architektur eine Aufgabe umsetzen. Die funktionalen Anforderungen bestimmen also nicht die Architektur. 
Die Qualitätsattribute sind nicht unabhängig voneinander, weil Qualität nur indirekt messbar ist und für jeden Stakeholder etwas anderes bedeutet. Auch wenn alle funktionalen Anforderungen umgesetzt wurden, muss das nicht heissen man hat eine qualitativ hochwertige Software geschrieben. Allerdings darf man auch nicht nur auf Qualität setzen, weil dann keine Features umgesetzt werden. Deshalb sollte man immer Kompromisse bei seinen Entscheidungen eingehen.

Qualitätsattribute lassen sich in Szenarien festhalten. Ein Szenario besteht immer aus folgenden Elementen:
\begin{itemize}
	\item Quelle des Auslösers (Benutzer, Entwickler)
	\item Auslöser / Ereignis
	\item Umgebung (zur Laufzeit, während Installation)
	\item Systembestandteil (z.B GUI oder Backend)
	\item Antwort / Reaktion
	\item Antwortmetrik (Wie messen wir die Antwort?)
\end{itemize}
Ein Qualitätsattribut lässt sich problemlos in mehrere Szenarien aufschlüsseln, damit die Anforderung detaillierter beschrieben werden kann. Hat man die Szenarien bis ins Detail ausgearbeitet, können Taktiken und Muster angewendet werden um die gewünschten Ergebnisse zu erhalten.
Nachfolgend werden einige Qualitätsattribute genauer beschrieben.

\subsection{Availability}

Funktionalitäten sind vorhanden und benutzbar wenn sie gebraucht werden. Das System muss also stabil und zuverlässig sein. Ein Ausfall sollte möglichst verhindert werden. Kommt es trotzdem zu einem Ausfall muss man das System in einer bestimmten Zeit wiederherstellen. Es können folgende Fehler auftreten (Auslöser eines Szenarios):
\begin{description}
	\item[Omission:] keine Antwort auf eine Anfrage
	\item[Crash:] Omissions treten wiederholt auf
	\item[Timing:] Response tritt zu falscher Zeit ein (zu früh, zu spät)
	\item[Response:] falscher Response des Systems
\end{description}
Diese Fehler können folgendermassen bekämpft werden:
\begin{description}
	\item[Prevention:] Einbau von Redundanz, Sicherheitsfunktionen oder Lastbegrenzungen
	\item[Detection \& Isolation:] Logging des Fehlers
	\item[Recovery:] Benachrichtigung von Benutzern und anderen Systemen, Aktionen zur Schadensbegrenzung oder einschränken der Verfügbarkeit oder Funktionalität des betroffenen Systems
\end{description}
Folgende Messwerte können zur Statistik verwendet werden:
\begin{itemize}
	\item Mean Time to Recover (MTTR)
	\item Mean Time to Failure (MTTF)
	\item Mean Time between Failure (MTBF)
\end{itemize}
\begin{figure}[h!]
\centering
\includegraphics[width=\linewidth]{fig/mbegriffe}
\caption{M-Begriffe}
\label{fig:mbegriffe}
\end{figure}

\subsection{Interoperability}

Die Interoperabilität beschreibt den Grad in dem zwei oder mehr Systeme Information sinnvoll austauschen können. Dabei geht es um die Schnittstellen mit anderen Systemen und wie diese Systeme die Daten interpretieren.

\subsection{Modifiability}

Die Modifizierbarkeit beschreibt welche Ressourcen für eine Änderung notwendig sind und wie hoch das Risiko dafür ist. Abbildung \ref{fig:modifiability} zeigt ein Beispiel-Szenario für die Erweiterbarkeit.

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/modifiability}
\caption{Szenario Modifiability}
\label{fig:modifiability}
\end{figure}

\subsection{Performance}

Die Performance beschreibt die Zeit in der ein System auf ein bestimmtes Ereignis reagiert. Messwerte sind Latenz (Zeit zwischen Ereignis und Reaktion), Durchsatz oder Jitter (Anzahl nicht verarbeiteter Events).

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/performance}
\caption{Szenario Performance}
\label{fig:performance}
\end{figure}

\subsection{Security}

Ein System soll Informationen vor nicht berechtigtem Zugriff schützen. Auch die Integrität der Daten muss gewährleistet sein. Darum müssen Angriffe erkannt und entsprechend darauf reagiert werden. Abbildung \ref{fig:security} zeigt ein mögliches Szenario.

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/security}
\caption{Szenario Security}
\label{fig:security}
\end{figure}

\subsection{Testability}

Die Testbarkeit ist die Einfachheit mit der Fehler im System festgestellt werden können. Abbildung \ref{fig:testability} zeigt ein mögliches Szenario.

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/testability}
\caption{Szenario Testability}
\label{fig:testability}
\end{figure}

\subsection{Usability}

Mit Usability ist die Benutzerfreundlichkeit eines Systems gemeint. So soll z.B. die Einarbeitung in ein neues System nicht viel Zeit in Anspruch nehmen. Abbildung \ref{fig:usability} zeigt ein mögliches Szenario.

\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{fig/usability}
\caption{Szenario Usability}
\label{fig:usability}
\end{figure}


\section{Prinzipien \& Taktiken}

\section{Stile und Muster}

\subsection{Stile}

Ein Architektur-Stil beschreibt ein Muster zur strukturellen Organisation einer Familie von Systemen. Diese fundamentale Struktur beschreibt folgende Eigenschaften eines Software-Systems:
\begin{itemize}
	\item Die Komponententypen und welche Funktionen diese zur Laufzeit erfüllen.
	\item Die topologische Anordnung dieser Komponenten.
	\item Die Konnektoren, welche die Kommunikation und Koordination zwischen den Komponenten regeln.
	\item Eine Menge von semantischen Einschränkungen, die bestimmen, wie Komponenten und Konnektoren miteinander verbunden werden können.
\end{itemize}
Es haben sich folgende Stil herausgebildet, die in den nachfolgenden Abschnitten beschrieben werden:
\begin{itemize}
	\item Schichten (Layers, Tiers)
	\item Pipes \& Filters
	\item Verteilte Systeme (Client/Server, Peer-to-Peer)
	\item Blackboard
	\item Service-orientierte Architekturen (SOA)
\end{itemize}

\subsubsection{Schichten}

Ein System wird in Schichten aufgeteilt, deren Elemente einen ähnlichen Abstraktionsgrad besitzen. Eine Schicht benutzt nur die Services, welche von der direkt darunterliegenden Schicht zur Verfügung gestellt werden. Das Überspringen einer Schicht zerstört die Architektur.  Schichten haben folgende Vor- bzw. Nachteile:
\begin{itemize}
	\item[+] Leicht verständliches Strukturkonzept
	\item[+] Minimiert Abhängigkeiten zwischen Komponenten
	\item[+] Schichten sind voneinander unabhängig in Erstellung und Betrieb
	\item[+] Änderungen in einer Schicht können maximal eine andere Schicht betreffen
	\item[--] Kann die Performance eines Systems beeinträchtigen, wenn Anfragen durch mehrere Schichten weitergereicht werden müssen
	\item[--] Änderungen im Datenmodell können alle Schichten betreffen (Datenverwaltung, Applikation, Präsentation)
\end{itemize}

\subsubsection{Pipes \& Filters}

Bei diesem Stil werden Verarbeitungseinheiten (Filter) hintereinander geschaltet und durch Datenkanäle (Pipes) verbunden. Jeder Filter gibt sein Ergebnis direkt an den nächsten Filter weiter. Pipes sind keine eigenen Komponenten in der Architektur sondern dienen rein als Konnektoren. Es sind verschiedene Koordinationsmodelle denkbar, so kann die Steuerung zentral oder dezentral sein, die Pipes aktiv oder passiv und die Datenübergabe komplett, stückchenweise oder zeitversetzt geschehen. Pipes \& Filters bieten folgende Vor- bzw. Nachteile:
\begin{itemize}
	\item[+] Einfache Implementierung
	\item[+] Klar verständliche Struktur
	\item[+] Klar strukturierte Abläufe
	\item[+] Mächtige Pipes können entscheiden, an welche Instanz eines Filters (Load balancing) oder an welchen Filter (Kapselung) sie die Daten weitergeben
	\item[--] Filter kennen einander nicht (Folgefehler können von ihnen nicht behandelt werden)
	\item[--] Konfiguration der Verarbeitungskette kann schwierig sein
	\item[--] Filter können nur über Daten kommunizieren (Gesamte Verarbeitungsinformation muss in den Daten oder der zentralen Steuerung enthalten sein)
\end{itemize}

\subsubsection{Verteilte Systeme}

Verteilte Systeme können entweder als Client/Server oder als P2P-Netzwerk betrieben werden. Der Client wird als Applikation lokal betriebn und kommuniziert über ein Anfrage-Antwort-Schema mit dem zentral zur Verfügung gestellten Server. Dabei kann auf dem Client zwischen Thin Client (z.B. Gmail) und Rich Client (z.B. Outlook) unterschieden werden. Der Client/Server-Stil bietet folgende Vor- bzw. Nachteile:
\begin{itemize}
	\item[+] Zentralisierung wichtiger, rechenintensiver oder sensibler Berechnungen im Server
	\item[+] Thin Clients einfach in Verteilung und Wartung
	\item[+] Rich Clients oft bei Server-Ausfall noch verwendbar
	\item[--] Netzbelastung hoch (besonders bei Thin Clients)
	\item[--] Verteilung der Funktionalität nicht immer einfach
	\item[--] Grenzen der Skalierung bei sehr hohen Clientzahlen
\end{itemize}

Bei einem P2P-Netzwerk kommunizieren verteilte Komponenten (Peers), die sowohl die Rolle von Clients als auch Servern wahrnehmen und sich Ressourcen teilen. Die Komponenten sind über eine Art Konnektor (z.B. Internet) miteinander verbunden. Bei einem P2P-Netzwerk gibt es keine zentrale Kontrolle, es kann also jeder Peer mit jedem Peer kommunizieren. Die Lokalisierung kann durch dezentrale Kommunikation (Peers tauschen untereinander ihre Listen bekannter Peers aus) oder durch einen zentralen Service realisiert werden. Das P2P-Netzwerk hat folgende Vor- bzw. Nachteile:
\begin{itemize}
	\item[+] Hohe Ausfallsicherheit (kein single point of failure)
	\item[+] Rechenintensive Aufgaben können verteilt werden
	\item[--] Auffinden und Erkennen von Peers in grossen Netzen
	\item[--] Potentielle Gefahr des Zerfalls des P2P Netzes (Nur bestimmte Gruppen von Peers kennen sich)
	\item[--] Fehlerbehandlung (Wer reagiert, wenn ein Peer seine Aufgaben falsch löst?)
	\item[--] Keine garantierten Antwortzeiten
\end{itemize}

\subsubsection{Blackboard}

Der Blackboard-Stil kommt ursprünglich aus der Künstlichen Intelligenz zur Lösung komplexer Probleme, für die kein deterministisches Lösungsverfahren existiert. An der Problemlösung arbeiten mehrere unabhängige Programme welche ein Blackboard als zentralen Datenspeicher verwenden. Die Programme kommunizieren also nicht untereinander sondern nur über ein zentrales Blackboard. Eine zentrale Steuerungskomponente bewertet den Lösungsfortschritt auf dem Blackboard und aktiviert die verfügbaren Programme. Das Blackboard hat folgende Vor- bzw. Nachteile:
\begin{itemize}
	\item[+] Einfache Integration komplexer Systeme
	\item[+] Parallelisierung der Berechnungen möglich
	\item[+] Moderne Variante: Tuple Space
	\item[--] Keine Garantie der Lösungsfindung
	\item[--] Finden der richtigen Kontrollstrategie ist schwierig
	\item[--] Keine garantierten Antwortzeiten
\end{itemize}

\subsubsection{SOA}

SOA wurde mega gehypt und nun machen sich alle darüber lustig und verwenden stattdessen Microservices, welche nun alle Probleme dieser Welt lösen. SOA versucht eine Spezifikation der Service, Datenformate und Kommunikationsprotokolle zu erreichen. Die Applikation wird dann als Orchestrierung von verschiedenen Services zur Erreichung der Geschäftsziele entworfen. Ein Service Consumer verwendet über ein Integration Layer (Middleware) ein Service eines Service Providers. Services tauche in allen Schichten auf und kommunizieren über einen zentralen Enterprise Service Bus. So gibt es natürlich Services für das Business aber auch für die Entwicklung oder die Infrastruktur. Service-orientierte Systeme sollten modular, verteilbar, auffindbar, austauschbar und wiederverwendbar sein. Wichtig dabei ist eine saubere Trennung der Verantwortlichkeiten und lose Kopplung. Ohne eine zentrale Stelle (SOA Governance) welche ein Überblick über das Ganze behält, wird jede Umsetzung von SOA scheitern. SOA bietet folgende Vor- bzw. Nachteile:
\begin{itemize}
	\item[+] descriptionSehr flexible Architekturform mit einfachem Grundmodell
	\item[+] Vielzahl von ausgereiften Standards
	\item[+] Verbindung von Business und IT
	\item[+] Voraussetzung für Cloud, Mashups usw.
	\item[--] Zusätzliche Komplexität wegen offener, dezentralisierter Systeme	
	\item[+] Vielzahl schwieriger Fragestellungen (Service design, Interoperabilität, Standards)
\end{itemize}

\subsection{Muster}

Ein Architekturmuster erfindet man nicht einfach, sondern erkennt man mithilfe von Erfahrungen aus der Praxis. Ein Muster setzt mehrere Taktiken um, aber macht auch immer einen Kompromiss zwischen mehreren Qualitätsattributen. Die Aufgabe des Architekten ist das richtige Muster anhand des Kontexts und den Rahmenbedingungen zu finden. Er muss sich auch genau überlegen, wie der Kompromiss des Musters die eigene Lösung beeinflusst. Ein Muster wird immer durch den Kontext, das Problem und die Lösung beschrieben.

Um ein System oder eine Komponente in eine bestehende Umgebung einzubinden existieren folgende vier Patterns (Enterprise Integration Patterns):
\begin{itemize}
	\item File Transfer
	\item Shared Database
	\item Remote Procedure Invocation (RPC)
	\item Messaging
\end{itemize}
Diese Patterns werden nachfolgend detailliert beschrieben:

\subsubsection{File Transfer}

Beim File Transfer wird eine Datei irgendwo zentral abgelegt, damit beide Applikationen drauf Zugriff haben. Dabei wird das Dateiformat und der Zeitintervall, in denen die Datei erzeugt und konsumiert wird, untereinander vereinbart. Dieses Muster bietet folgende Vor- bzw. Nachteile:
\begin{itemize}
	\item[+] Dateien als universelles Speichermedium
	\item[+] Minimale Anforderungen an Hardware/Software
	\item[+] Keine Kenntnisse der Applikation notwendig für Integration
	\item[+] Keine weitergehenden Abhängigkeiten zwischen integrierten Applikationen	
	\item[--] Synchronisation der Daten kann bei Änderungen schnell verloren gehen	
	\item[--] Ungeeignet für den sehr häufigen Austausch kleinerer Datenmengen (Dateimanagementproblem)
\end{itemize}

\subsubsection{Shared Database}

Bei diesem Muster wird eine Datenbank zwischen verschiedenen Applikationen geteilt. Dadurch werden die Daten konsistent und in einem einheitlichen Datenformat über die Anwendungen ausgetauscht. Die Veränderung der Daten ist über Datenbanktransaktionen gesichert. Die Shared Database bietet folgende Vor- bzw. Nachteile:
\begin{itemize}
	\item[+] Unterstützung von Datenbankstandards in allen Entwicklungsumgebungen
	\item[+] Synchronisation der Daten gesichert
	\item[--] Applikationen müssen an Datenformate angepasst werden (Adapter, Transformationen)
	\item[--] Einigung aller Applikationen auf ein einheitliches Format
	\item[--] Externe Applikationen arbeiten oft nur mit ihren eigenen Formaten (Bedarf nach zusätzlichen Adaptern)
	\item[--] Datenbank als potentieller single point of failure für alle Applikationen
	\item[--] Performanzprobleme
\end{itemize}

\subsubsection{Remote Procedure Invocation}

Beim RPC-Muster werden Methoden auf entfernten Anwendungen aufgerufen. Dabei werden die Daten zu einer Funktionalität gekoppelt. Eine Applikation wird als Komponente gekapselt, welche ihre Funktionalität über eine Schnittstelle anderen Applikationen zur Verfügung stellt. Dieses Muster bietet folgende Vor- bzw. Nachteile:
\begin{itemize}
	\item[+] Applikationen können interne Datenformate ändern
	\item[+] Unterschiedliche Schnittstellen können bereitgestellt werden
	\item[+] Einfaches Entwicklungskonzept ("Prozeduraufruf")
	\item[--] Abstimmung und Änderung von Schnittstellen über mehrere Applikationsgrenzen kann schwierig sein
	\item[--] Aufrechterhalten von veralteten Schnittstellen
	\item[--] Performanz- und Zuverlässigkeitsprobleme von Remote Aufrufen ("remote" <> "local")
	\item[--] Enge Kopplung der Applikationen ("growing knot")
\end{itemize}

\subsubsection{Messaging}

Durch Messaging wird eine lose Kopplung unter den einzelnen Systemen erreicht. Dabei wird zwischen synchroner, asynchroner und Publish-Subscribe Kommunikationsstilen unterschieden. Messaging bietet folgende Vor- bzw. Nachteile:
\begin{itemize}
	\item[+] Flexibelste Integrationslösung
	\item[+] Unterstützung durch zahlreiche Technologien
	\item[+] Transformation und Management der Daten innerhalb der Messaging Middleware und nicht in der Applikation
	\item[--] Asynchrones Design von Applikationsfunktionen nicht immer einfach
	\item[--] Testen und Debugging schwieriger
	\item[--] Flexibilität führt zu zahlreichen Folgefragen, die gelöst werden müssen
\end{itemize}

\section{Sichten, Architekturentscheidungen und Dokumentation}

\section{Bewertung von Architekturen (ATAM)}

\section{Beruf des IT Architekten}

\section{Fallstudie Fillialbestellsystem aus Modul Applikationsentwicklung}